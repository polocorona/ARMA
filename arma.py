# -*- coding: utf-8 -*-
"""ARMA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12hZ1zREJNbpy5sAQWGBdYwhs_uhpc_NT
"""

# Install required libraries in Colab
!pip install yfinance statsmodels matplotlib pandas numpy

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller, coint
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import warnings
warnings.filterwarnings("ignore")

# Set random seed for reproducibility
np.random.seed(42)

# Step 1: Fetch stock data for AAPL and MSFT from Nov 29, 2019
start_date = "2019-11-29"
end_date = "2025-02-28"

print("Fetching data for AAPL...")
aapl_data = yf.download("AAPL", start=start_date, end=end_date)
print("Fetching data for MSFT...")
msft_data = yf.download("MSFT", start=start_date, end=end_date)

# Extract 'Close' prices (assuming single-column data from yf.download)
aapl_prices = aapl_data["Close"].dropna()
msft_prices = msft_data["Close"].dropna()

# Align indices for cointegration test
combined = pd.concat([aapl_prices, msft_prices], axis=1).dropna()
aapl_prices = combined.iloc[:, 0]
msft_prices = combined.iloc[:, 1]

# Step 2: Simulate a Random Walk
def random_walk_simulation(initial_price, steps, scale=1):
    random_steps = np.random.normal(loc=0, scale=scale, size=steps)
    random_steps[0] = 0
    return initial_price + np.cumsum(random_steps)

aapl_rw = random_walk_simulation(aapl_prices.iloc[0], len(aapl_prices), scale=5)
msft_rw = random_walk_simulation(msft_prices.iloc[0], len(msft_prices), scale=5)

# Step 3: Unit Root Test (ADF)
def unit_root_test(series, name):
    result = adfuller(series.dropna())
    print(f"\nUnit Root Test (ADF) for {name}:")
    print(f"ADF Statistic: {result[0]:.4f}")
    print(f"p-value: {result[1]:.4f}")
    print("Critical Values:", {k: round(v, 4) for k, v in result[4].items()})
    if result[1] > 0.05:
        print(f"{name} likely has a unit root (non-stationary).")
    else:
        print(f"{name} does not have a unit root (stationary).")

aapl_returns = aapl_prices.pct_change().dropna()
msft_returns = msft_prices.pct_change().dropna()

unit_root_test(aapl_prices, "AAPL Prices")
unit_root_test(msft_prices, "MSFT Prices")
unit_root_test(aapl_returns, "AAPL Returns")
unit_root_test(msft_returns, "MSFT Returns")

# Step 4: Fit ARMA Model (ARMA(1,1))
def fit_arma(series, name):
    model = ARIMA(series, order=(1, 0, 1))
    fit = model.fit()
    print(f"\nARMA(1,1) Model Summary for {name}:")
    print(fit.summary().tables[1])
    return fit

aapl_arma = fit_arma(aapl_returns, "AAPL Returns")
msft_arma = fit_arma(msft_returns, "MSFT Returns")

# Step 5: Correlogram and Partial Correlogram of Residuals
plt.figure(figsize=(12, 8))

plt.subplot(2, 2, 1)
plot_acf(aapl_arma.resid, ax=plt.gca(), title="ACF of AAPL ARMA Residuals")
plt.subplot(2, 2, 2)
plot_pacf(aapl_arma.resid, ax=plt.gca(), title="PACF of AAPL ARMA Residuals")
plt.subplot(2, 2, 3)
plot_acf(msft_arma.resid, ax=plt.gca(), title="ACF of MSFT ARMA Residuals")
plt.subplot(2, 2, 4)
plot_pacf(msft_arma.resid, ax=plt.gca(), title="PACF of MSFT ARMA Residuals")
plt.tight_layout()
plt.show()

# Step 6: Cointegration Test (Engle-Granger)
print("\nCointegration Test (Engle-Granger) between AAPL and MSFT Prices:")
coint_result = coint(aapl_prices, msft_prices)
print(f"Cointegration Test Statistic: {coint_result[0]:.4f}")
print(f"p-value: {coint_result[1]:.4f}")
print("Critical Values:", {k: round(v, 4) for k, v in zip(['1%', '5%', '10%'], coint_result[2])})
if coint_result[1] < 0.05:
    print("Result: Reject the null hypothesis - AAPL and MSFT prices are cointegrated.")
else:
    print("Result: Fail to reject the null hypothesis - AAPL and MSFT prices are not cointegrated.")

# Step 7: Plotting Original Analyses
plt.figure(figsize=(14, 10))

# Random Walk vs Actual Prices
plt.subplot(3, 1, 1)
plt.plot(aapl_prices.index, aapl_prices, label="AAPL Actual", color="blue")
plt.plot(aapl_prices.index, aapl_rw, label="AAPL Random Walk", color="orange", linestyle="--")
plt.plot(msft_prices.index, msft_prices, label="MSFT Actual", color="green")
plt.plot(msft_prices.index, msft_rw, label="MSFT Random Walk", color="red", linestyle="--")
plt.title("Stock Prices vs Random Walk Simulation")
plt.xlabel("Date")
plt.ylabel("Price")
plt.legend()

# Returns
plt.subplot(3, 1, 2)
plt.plot(aapl_returns.index, aapl_returns, label="AAPL Returns", color="blue")
plt.plot(msft_returns.index, msft_returns, label="MSFT Returns", color="green")
plt.title("Daily Returns")
plt.xlabel("Date")
plt.ylabel("Returns")
plt.legend()

# ARMA Forecasts (last 30 days)
aapl_forecast = aapl_arma.forecast(steps=30)
msft_forecast = msft_arma.forecast(steps=30)
forecast_index = pd.date_range(start=aapl_returns.index[-1], periods=30, freq="B")

plt.subplot(3, 1, 3)
plt.plot(aapl_returns.index[-30:], aapl_returns[-30:], label="AAPL Actual Returns", color="blue")
plt.plot(forecast_index, aapl_forecast, label="AAPL ARMA Forecast", color="orange", linestyle="--")
plt.plot(msft_returns.index[-30:], msft_returns[-30:], label="MSFT Actual Returns", color="green")
plt.plot(forecast_index, msft_forecast, label="MSFT ARMA Forecast", color="red", linestyle="--")
plt.title("ARMA(1,1) Forecast vs Actual Returns (Last 30 Days)")
plt.xlabel("Date")
plt.ylabel("Returns")
plt.legend()

plt.tight_layout()
plt.show()

# Install required libraries in Colab
!pip install yfinance statsmodels matplotlib pandas numpy

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller, coint
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import warnings
warnings.filterwarnings("ignore")

# Set random seed for reproducibility
np.random.seed(42)

# Step 1: Fetch stock data for TSLA and GM from Nov 29, 2019
start_date = "2019-11-29"
end_date = "2025-02-28"

print("Fetching data for TSLA...")
tsla_data = yf.download("TSLA", start=start_date, end=end_date)
print("Fetching data for GM...")
gm_data = yf.download("GM", start=start_date, end=end_date)

# Extract 'Close' prices (single-column data from yf.download)
tsla_prices = tsla_data["Close"].dropna()
gm_prices = gm_data["Close"].dropna()

# Align indices for cointegration test
combined = pd.concat([tsla_prices, gm_prices], axis=1).dropna()
tsla_prices = combined.iloc[:, 0]
gm_prices = combined.iloc[:, 1]

# Step 2: Simulate a Random Walk
def random_walk_simulation(initial_price, steps, scale=1):
    random_steps = np.random.normal(loc=0, scale=scale, size=steps)
    random_steps[0] = 0
    return initial_price + np.cumsum(random_steps)

tsla_rw = random_walk_simulation(tsla_prices.iloc[0], len(tsla_prices), scale=5)
gm_rw = random_walk_simulation(gm_prices.iloc[0], len(gm_prices), scale=5)

# Step 3: Unit Root Test (ADF)
def unit_root_test(series, name):
    result = adfuller(series.dropna())
    print(f"\nUnit Root Test (ADF) for {name}:")
    print(f"ADF Statistic: {result[0]:.4f}")
    print(f"p-value: {result[1]:.4f}")
    print("Critical Values:", {k: round(v, 4) for k, v in result[4].items()})
    if result[1] > 0.05:
        print(f"{name} likely has a unit root (non-stationary).")
    else:
        print(f"{name} does not have a unit root (stationary).")

tsla_returns = tsla_prices.pct_change().dropna()
gm_returns = gm_prices.pct_change().dropna()

unit_root_test(tsla_prices, "TSLA Prices")
unit_root_test(gm_prices, "GM Prices")
unit_root_test(tsla_returns, "TSLA Returns")
unit_root_test(gm_returns, "GM Returns")

# Step 4: Fit ARMA Model (ARMA(1,1))
def fit_arma(series, name):
    model = ARIMA(series, order=(1, 0, 1))
    fit = model.fit()
    print(f"\nARMA(1,1) Model Summary for {name}:")
    print(fit.summary().tables[1])
    return fit

tsla_arma = fit_arma(tsla_returns, "TSLA Returns")
gm_arma = fit_arma(gm_returns, "GM Returns")

# Step 5: Correlogram and Partial Correlogram of Residuals
plt.figure(figsize=(12, 8))

plt.subplot(2, 2, 1)
plot_acf(tsla_arma.resid, ax=plt.gca(), title="ACF of TSLA ARMA Residuals")
plt.subplot(2, 2, 2)
plot_pacf(tsla_arma.resid, ax=plt.gca(), title="PACF of TSLA ARMA Residuals")
plt.subplot(2, 2, 3)
plot_acf(gm_arma.resid, ax=plt.gca(), title="ACF of GM ARMA Residuals")
plt.subplot(2, 2, 4)
plot_pacf(gm_arma.resid, ax=plt.gca(), title="PACF of GM ARMA Residuals")
plt.tight_layout()
plt.show()

# Step 6: Cointegration Test (Engle-Granger)
print("\nCointegration Test (Engle-Granger) between TSLA and GM Prices:")
coint_result = coint(tsla_prices, gm_prices)
print(f"Cointegration Test Statistic: {coint_result[0]:.4f}")
print(f"p-value: {coint_result[1]:.4f}")
print("Critical Values:", {k: round(v, 4) for k, v in zip(['1%', '5%', '10%'], coint_result[2])})
if coint_result[1] < 0.05:
    print("Result: Reject the null hypothesis - TSLA and GM prices are cointegrated.")
else:
    print("Result: Fail to reject the null hypothesis - TSLA and GM prices are not cointegrated.")

# Step 7: Plotting Original Analyses
plt.figure(figsize=(14, 10))

# Random Walk vs Actual Prices
plt.subplot(3, 1, 1)
plt.plot(tsla_prices.index, tsla_prices, label="TSLA Actual", color="blue")
plt.plot(tsla_prices.index, tsla_rw, label="TSLA Random Walk", color="orange", linestyle="--")
plt.plot(gm_prices.index, gm_prices, label="GM Actual", color="green")
plt.plot(gm_prices.index, gm_rw, label="GM Random Walk", color="red", linestyle="--")
plt.title("Stock Prices vs Random Walk Simulation")
plt.xlabel("Date")
plt.ylabel("Price")
plt.legend()

# Returns
plt.subplot(3, 1, 2)
plt.plot(tsla_returns.index, tsla_returns, label="TSLA Returns", color="blue")
plt.plot(gm_returns.index, gm_returns, label="GM Returns", color="green")
plt.title("Daily Returns")
plt.xlabel("Date")
plt.ylabel("Returns")
plt.legend()

# ARMA Forecasts (last 30 days)
tsla_forecast = tsla_arma.forecast(steps=30)
gm_forecast = gm_arma.forecast(steps=30)
forecast_index = pd.date_range(start=tsla_returns.index[-1], periods=30, freq="B")

plt.subplot(3, 1, 3)
plt.plot(tsla_returns.index[-30:], tsla_returns[-30:], label="TSLA Actual Returns", color="blue")
plt.plot(forecast_index, tsla_forecast, label="TSLA ARMA Forecast", color="orange", linestyle="--")
plt.plot(gm_returns.index[-30:], gm_returns[-30:], label="GM Actual Returns", color="green")
plt.plot(forecast_index, gm_forecast, label="GM ARMA Forecast", color="red", linestyle="--")
plt.title("ARMA(1,1) Forecast vs Actual Returns (Last 30 Days)")
plt.xlabel("Date")
plt.ylabel("Returns")
plt.legend()

plt.tight_layout()
plt.show()

# Install required libraries in Colab
!pip install yfinance statsmodels matplotlib pandas numpy

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller, coint
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import warnings
warnings.filterwarnings("ignore")

# Set random seed for reproducibility
np.random.seed(42)

# Step 1: Fetch stock data for GOOGL and AMZN from Nov 29, 2019
start_date = "2019-11-29"
end_date = "2025-02-28"

print("Fetching data for GOOGL...")
googl_data = yf.download("GOOGL", start=start_date, end=end_date)
print("Fetching data for AMZN...")
amzn_data = yf.download("AMZN", start=start_date, end=end_date)

# Extract 'Close' prices (single-column data from yf.download)
googl_prices = googl_data["Close"].dropna()
amzn_prices = amzn_data["Close"].dropna()

# Align indices for cointegration test
combined = pd.concat([googl_prices, amzn_prices], axis=1).dropna()
googl_prices = combined.iloc[:, 0]
amzn_prices = combined.iloc[:, 1]

# Step 2: Simulate a Random Walk
def random_walk_simulation(initial_price, steps, scale=1):
    random_steps = np.random.normal(loc=0, scale=scale, size=steps)
    random_steps[0] = 0
    return initial_price + np.cumsum(random_steps)

googl_rw = random_walk_simulation(googl_prices.iloc[0], len(googl_prices), scale=5)
amzn_rw = random_walk_simulation(amzn_prices.iloc[0], len(amzn_prices), scale=5)

# Step 3: Unit Root Test (ADF)
def unit_root_test(series, name):
    result = adfuller(series.dropna())
    print(f"\nUnit Root Test (ADF) for {name}:")
    print(f"ADF Statistic: {result[0]:.4f}")
    print(f"p-value: {result[1]:.4f}")
    print("Critical Values:", {k: round(v, 4) for k, v in result[4].items()})
    if result[1] > 0.05:
        print(f"{name} likely has a unit root (non-stationary).")
    else:
        print(f"{name} does not have a unit root (stationary).")

googl_returns = googl_prices.pct_change().dropna()
amzn_returns = amzn_prices.pct_change().dropna()

unit_root_test(googl_prices, "GOOGL Prices")
unit_root_test(amzn_prices, "AMZN Prices")
unit_root_test(googl_returns, "GOOGL Returns")
unit_root_test(amzn_returns, "AMZN Returns")

# Step 4: Fit ARMA Model (ARMA(1,1))
def fit_arma(series, name):
    model = ARIMA(series, order=(1, 0, 1))
    fit = model.fit()
    print(f"\nARMA(1,1) Model Summary for {name}:")
    print(fit.summary().tables[1])
    return fit

googl_arma = fit_arma(googl_returns, "GOOGL Returns")
amzn_arma = fit_arma(amzn_returns, "AMZN Returns")

# Step 5: Correlogram and Partial Correlogram of Residuals
plt.figure(figsize=(12, 8))

plt.subplot(2, 2, 1)
plot_acf(googl_arma.resid, ax=plt.gca(), title="ACF of GOOGL ARMA Residuals")
plt.subplot(2, 2, 2)
plot_pacf(googl_arma.resid, ax=plt.gca(), title="PACF of GOOGL ARMA Residuals")
plt.subplot(2, 2, 3)
plot_acf(amzn_arma.resid, ax=plt.gca(), title="ACF of AMZN ARMA Residuals")
plt.subplot(2, 2, 4)
plot_pacf(amzn_arma.resid, ax=plt.gca(), title="PACF of AMZN ARMA Residuals")
plt.tight_layout()
plt.show()

# Step 6: Cointegration Test (Engle-Granger)
print("\nCointegration Test (Engle-Granger) between GOOGL and AMZN Prices:")
coint_result = coint(googl_prices, amzn_prices)
print(f"Cointegration Test Statistic: {coint_result[0]:.4f}")
print(f"p-value: {coint_result[1]:.4f}")
print("Critical Values:", {k: round(v, 4) for k, v in zip(['1%', '5%', '10%'], coint_result[2])})
if coint_result[1] < 0.05:
    print("Result: Reject the null hypothesis - GOOGL and AMZN prices are cointegrated.")
else:
    print("Result: Fail to reject the null hypothesis - GOOGL and AMZN prices are not cointegrated.")

# Step 7: Plotting Original Analyses
plt.figure(figsize=(14, 10))

# Random Walk vs Actual Prices
plt.subplot(3, 1, 1)
plt.plot(googl_prices.index, googl_prices, label="GOOGL Actual", color="blue")
plt.plot(googl_prices.index, googl_rw, label="GOOGL Random Walk", color="orange", linestyle="--")
plt.plot(amzn_prices.index, amzn_prices, label="AMZN Actual", color="green")
plt.plot(amzn_prices.index, amzn_rw, label="AMZN Random Walk", color="red", linestyle="--")
plt.title("Stock Prices vs Random Walk Simulation")
plt.xlabel("Date")
plt.ylabel("Price")
plt.legend()

# Returns
plt.subplot(3, 1, 2)
plt.plot(googl_returns.index, googl_returns, label="GOOGL Returns", color="blue")
plt.plot(amzn_returns.index, amzn_returns, label="AMZN Returns", color="green")
plt.title("Daily Returns")
plt.xlabel("Date")
plt.ylabel("Returns")
plt.legend()

# ARMA Forecasts (last 30 days)
googl_forecast = googl_arma.forecast(steps=30)
amzn_forecast = amzn_arma.forecast(steps=30)
forecast_index = pd.date_range(start=googl_returns.index[-1], periods=30, freq="B")

plt.subplot(3, 1, 3)
plt.plot(googl_returns.index[-30:], googl_returns[-30:], label="GOOGL Actual Returns", color="blue")
plt.plot(forecast_index, googl_forecast, label="GOOGL ARMA Forecast", color="orange", linestyle="--")
plt.plot(amzn_returns.index[-30:], amzn_returns[-30:], label="AMZN Actual Returns", color="green")
plt.plot(forecast_index, amzn_forecast, label="AMZN ARMA Forecast", color="red", linestyle="--")
plt.title("ARMA(1,1) Forecast vs Actual Returns (Last 30 Days)")
plt.xlabel("Date")
plt.ylabel("Returns")
plt.legend()

plt.tight_layout()
plt.show()

#@title Convert ipynb to HTML in Colab
# Upload ipynb
from google.colab import files
f = files.upload()

# Convert ipynb to html
import subprocess
file0 = list(f.keys())[0]
_ = subprocess.run(["pip", "install", "nbconvert"])
_ = subprocess.run(["jupyter", "nbconvert", file0, "--to", "html"])

# download the html
files.download(file0[:-5]+"html")